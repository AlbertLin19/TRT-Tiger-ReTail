{% extends "marketplace/base.html" %}
{% block content %}

<div class="container">
    <div class="row my-4">
        <div class="col-6">
            <div class="input-group rounded">
              <input type="search" id="searchbar" onkeyup="updateQuery()" placeholder="Search" class="form-control" />
              <button class="btn btn-secondary" type="submit" onkeyup="updateQuery()"><i class=" fa fa-search"></i></button>
            </div>
        </div>
        <div class="col-6">
            CATEGORIES
            {% for category in categories %}
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" id="category_{{category.pk}}" oninput="updateQuery()">
                    <label class="form-check-label" for="category_{{category.pk}}">
                        {{category.name}}
                    </label>
                </div>
            {% endfor %}

            CONDITIONS 
            {% for condition in Item.CONDITIONS %}
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" id="condition_{{condition.index}}" oninput="updateQuery()">
                    <label class="form-check-label" for="condition_{{condition.index}}">
                        {{condition.name}}
                    </label>
                </div>
            {% endfor %}
        </div>
    </div>
</div>
<div class="container">
    <table class="table table-striped">
        <thead>
            <tr>
            <th scope="col">Name</th>
            <th scope="col">Price</th>
            <th scope="col">Description</th>
            </tr>
        </thead>
        <tbody id="table_body">
        </tbody>
    </table>
</div>

<script>
    'use strict';
    const category_pks = [{% for category in categories %}{{category.pk}}, {% endfor %}];
    const condition_indexes = [{% for condition in Item.CONDITIONS %}{{condition.index}}, {% endfor %}];
    let active_category_pks = [];
    let active_condition_indexes = [];
    let search_string = "";

    let items = [];        // continuously gathered items, sorted by most relevant first
    let base_item_pk = -1;
    let restart = false;   // indicates that items should be cleared

    // set active_category_pks, active_condition_indexes, search_string appropriately
    // based on current inputs
    function updateQuery() {
        active_category_pks = [];
        active_condition_indexes = [];

        for (const category_pk of category_pks) {
            if ($("#category_"+category_pk).is(':checked')) {
                active_category_pks.push(category_pk);
            }
        }
        for (const condition_index of condition_indexes) {
            if ($("#condition_"+condition_index).is(':checked')) {
                active_condition_indexes.push(condition_index);
            }
        }

        search_string = $("#searchbar").val();
        restart = true; // trigger a clear of the items array
    }

    // generates and injects the items HTML
    function injectItemsHTML() {
        let html = "";
        for (const item of items) {
            html += "<tr>";
            html += "<td>" + item["name"] + "</td>";
            html += "<td>" + item["price"] + "</td>";
            html += "<td>" + item["description"] + "</td>";
            html += "</tr>";
        }
        $('#table_body').html(html);
    }

    // retrieve items repeatedly in a synchronous fashion 
    // (only this function should ever touch the items array and base_item_pk to avoid concurrency issues)
    function populateItemsSynchronously(count, period) {
        if (restart) {
            restart = false;
            items = [];
            base_item_pk = -1;
            window.setTimeout(populateItemsSynchronously(count, period), period);
            return;
        }

        // populate items
        let categories_str = "";
        for (const category_pk of active_category_pks) {
            categories_str += category_pk + ",";
        }
        let conditions_str = "";
        for (const condition_index of active_condition_indexes) {
            conditions_str += condition_index + ",";
        }
        fetch("/items/get_relative/?count=" + count + "&direction=backward&base_item_pk=" + base_item_pk + "&search_string=" + search_string + "&condition_indexes=" + conditions_str + "&category_pks=" + categories_str)
            .then((resp) => {return resp.json();})
            .then((data) => {
                if (data["items"].length != 0) {
                    items.push(...data["items"]);
                    base_item_pk = data["items"][data["items"].length - 1]["pk"];
                    injectItemsHTML();
                }
                window.setTimeout(populateItemsSynchronously(count, period), period); 
                // notice that setTimeout is called only in callback after fetch, to avoid concurrency issues
                // (the call to setTimeout in the .catch only occurs if .then doesn't execute)
                return;
            })
            .catch((error) => {
                window.setTimeout(populateItemsSynchronously(count, period), period);
                return console.log(error);
            });
        return;
    }

    function setup() {
            window.setTimeout(() => {populateItemsSynchronously(5, 10)}, 0);
        }

    $('document').ready(setup);

</script>
{% endblock content %}